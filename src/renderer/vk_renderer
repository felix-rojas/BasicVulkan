/**
 * @file vk_renderer
 * @author your name (you@domain.com)
 * @brief file to initialize vulkan depending on the OS
 * @version 0.1
 * @date 2023-06-15
 *
 *
 */

#include <vulkan/vulkan.h>
#ifdef WINDOWS_BUILD
#include <vulkan/vulkan_win32.h>
#elif LINUX_BUILD
#endif
#include <iostream>

#define ArraySize(arr) sizeof((arr)) / sizeof((arr[0]))

/**
 * @brief Error handling for development
 *
 */
#define VK_CHECK(result)                                           \
    if (result != VK_SUCCESS)                                      \
    {                                                              \
        std::cout << "Vulcan Error code: " << result << std::endl; \
        __debugbreak();                                            \
        return false;                                              \
    }

struct VkContext
{
    VkInstance instance;
    VkSurfaceKHR surface;
    VkPhysicalDevice gpu;
    VkDevice device;
    VkSwapchainKHR swapchain;
    int graphicsIndex;
};

/**
 * @brief initializes the instance and surface required for vulkan instance
 *
 * @param vkcontext defined
 * @param window is a void pointer for other OS builds
 * @return true if instance was succesfully initialized
 */
bool vk_init(VkContext *vkcontext, HWND window)
{
    VkApplicationInfo appInfo = {};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = "Vulkan_app";
    appInfo.pEngineName = "VulkanEngine";

    // array of the necessary extensions for each OS
    char *surface_extensions[] = {
#ifdef WINDOWS_BUILD
        VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
#elif LINUX_BUILD
#endif
        VK_EXT_DEBUG_UTILS_EXTENSION_NAME,
        VK_KHR_SURFACE_EXTENSION_NAME};

        char* validationLayers[] = {
            "VK_LAYER_KHRONOS_VALIDATION"
        };

    VkInstanceCreateInfo instanceInfo = {};
    instanceInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    instanceInfo.pApplicationInfo = &appInfo;
    instanceInfo.ppEnabledExtensionNames = surface_extensions;
    instanceInfo.enabledExtensionCount = ArraySize(surface_extensions);
    instanceInfo.ppEnabledLayerNames = validationLayers;
    instanceInfo.enabledLayerCount = ArraySize(validationLayers);
    VK_CHECK(vkCreateInstance(&instanceInfo, 0, &vkcontext->instance));

    /**
     * @brief Localized scope for surface creation
     */
    {
#ifdef WINDOWS_BUILD
        VkWin32SurfaceCreateInfoKHR surfaceInfo = {};
        surfaceInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
        surfaceInfo.hwnd = (HWND)window;
        surfaceInfo.hinstance = GetModuleHandleA(0);
        VK_CHECK(vkCreateWin32SurfaceKHR(vkcontext->instance, &surfaceInfo, 0, &vkcontext->surface));
#elif LINUX_BUILD
#endif
    }

    // Localized scope for choosing GPU
    {
        vkcontext->graphicsIndex = -1;
        uint32_t gpuCount = 0;
        // TODO: Suballocation from main allocation
        VkPhysicalDevice gpus[10];

        VK_CHECK(vkEnumeratePhysicalDevices(vkcontext->instance, &gpuCount, 0));
        VK_CHECK(vkEnumeratePhysicalDevices(vkcontext->instance, &gpuCount, gpus));

        for (uint32_t i = 0; i < gpuCount; i++)
        {
            VkPhysicalDevice gpu = gpus[i];

            // check for queue families
            uint32_t queueFamilyCount = 0;
            // TODO: Suballocation from main allocation
            VkQueueFamilyProperties queueProperties[10];
            vkGetPhysicalDeviceQueueFamilyProperties(gpu, &queueFamilyCount, 0);
            vkGetPhysicalDeviceQueueFamilyProperties(gpu, &queueFamilyCount, queueProperties);
            for (uint32_t j = 0; j < queueFamilyCount; j++)
            {
                // is it capable of using graphics?
                if (queueProperties[j].queueFlags && VK_QUEUE_GRAPHICS_BIT)
                {
                    // can it present images to our surface?
                    VkBool32 surfaceSupport = VK_FALSE;
                    VK_CHECK(vkGetPhysicalDeviceSurfaceSupportKHR(gpu, j, vkcontext->surface, &surfaceSupport));

                    if (surfaceSupport)
                    {
                        vkcontext->graphicsIndex = j;
                        vkcontext->gpu = gpu;
                        break;
                    }
                }
            }
        }

        if (vkcontext->graphicsIndex < 0) // if there are no graphic processing capabilites, stop
        {
            return false;
        }
    }

    // Localized scope to set a logical device

    {
        float queuePriority = 1.0f;

        VkDeviceQueueCreateInfo queueInfo = {};
        queueInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
        queueInfo.queueFamilyIndex = vkcontext->graphicsIndex;
        queueInfo.pQueuePriorities = &queuePriority;

        char* swapchain_extensions[] = {
            VK_KHR_SWAPCHAIN_EXTENSION_NAME
        };

        VkDeviceCreateInfo deviceInfo = {};
        deviceInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        deviceInfo.pQueueCreateInfos = &queueInfo;
        deviceInfo.queueCreateInfoCount = 1;
        deviceInfo.enabledExtensionCount = ArraySize(swapchain_extensions);
        deviceInfo.ppEnabledExtensionNames = swapchain_extensions;

        VK_CHECK(vkCreateDevice(vkcontext->gpu, &deviceInfo, 0, &vkcontext->device));
    }
    // define the swapchain to manage the images
    {
        VkSwapchainCreateInfoKHR swapchainInfo = {};
        swapchainInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
        swapchainInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
        swapchainInfo.surface = vkcontext->surface;


        VK_CHECK(vkCreateSwapchainKHR(vkcontext->device, &swapchainInfo, 0, &vkcontext->swapchain));
    }

    return true;
}